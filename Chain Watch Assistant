// ==UserScript==
// @name         Torn Chain Watch Assistant DevTest
// @namespace    https://greasyfork.org/users/TheGingerbeardman
// @version      2.9
// @description  Monitors chain timer, alerts on user defined thresholds, and finds targets to save the chain.
// @author       Gingerbeardman
// @match        https://www.torn.com/*
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// @credit       tos https://greasyfork.org/en/scripts/370905-chain-warn-v2
// @credit       Omanpx [1906686], Titanic_ [2968477] https://greasyfork.org/en/scripts/511611-faction-target-finder
// @license      GPLv3
// @downloadURL https://update.greasyfork.org/scripts/554062/Torn%20Chain%20Watch%20Assistant.user.js
// @updateURL https://update.greasyfork.org/scripts/554062/Torn%20Chain%20Watch%20Assistant.meta.js
// ==/UserScript==

(function () {
  'use strict';

  const STORAGE_KEYS = {
    enabled: 'chain_watch_enabled',
    apiKey: 'chain_watch_api_key',
    thresholds: 'chain_watch_thresholds',
    lastNotification: 'chain_watch_last_notification',
    leaderTabId: 'chain_watch_leader_tab_id',
    leaderHeartbeat: 'chain_watch_leader_heartbeat',
  };

  // Generate unique tab ID
  const TAB_ID = Math.random().toString(36).substring(2, 15);

  const state = {
    enabled: localStorage.getItem(STORAGE_KEYS.enabled) === 'true',
    apiKey: localStorage.getItem(STORAGE_KEYS.apiKey) || '',
    thresholds: JSON.parse(localStorage.getItem(STORAGE_KEYS.thresholds) || '{}'),
    overlay: null,
    audioAlarm: null,
    interval: null,
    overlayDismissed: false,
    lastFetchedTime: null,      // When we last fetched from API (timestamp)
    lastFetchedValue: null,     // The timer value we fetched (in seconds)
    usingDOMFallback: false,    // Whether we're using DOM as fallback
    previouslyUsingDOMFallback: false,  // Previous state to detect transitions
    apiFailureNotified: false,  // Whether we've shown notification for current failure
    consecutiveAPIFailures: 0,  // Track consecutive API failures
    lastAPIAttemptTime: 0,      // When we last attempted an API call (timestamp)
    apiCooldownUntil: 0,        // Timestamp until which API calls are paused after failures
    isLeader: false,            // Whether this tab is currently the leader
    lastHeartbeatUpdate: 0,     // When heartbeat was last updated
    lastDisplayedSeconds: null, // Last timer value displayed (for conditional updates)
  };

  const TARGET_FALLBACK_FACTIONS = [1111, 2222, 3333];
  const MAX_LEVEL = 100;
  const API_TIMEOUT = 5000;  // 5 second timeout per request
  const API_PING_INTERVAL = 5000;  // Ping API every 5 seconds (12/min)
  const MAX_API_FAILURES = 3;  // Switch to DOM after 3 consecutive failures (15 seconds total)
  const LEADER_STALE_THRESHOLD = 5000;  // Leader is stale if no heartbeat for 5 seconds
  const HEARTBEAT_UPDATE_INTERVAL = 2000;  // Update heartbeat every 2 seconds

  // Leader tab management
  const isLeader = () => {
    const currentLeader = localStorage.getItem(STORAGE_KEYS.leaderTabId);
    const lastHeartbeat = parseInt(localStorage.getItem(STORAGE_KEYS.leaderHeartbeat) || '0', 10);
    const now = Date.now();

    // If we're the current leader, return true
    if (currentLeader === TAB_ID) return true;

    // If there's no leader or the leader is stale, we can claim leadership
    if (!currentLeader || (now - lastHeartbeat) > LEADER_STALE_THRESHOLD) {
      claimLeadership();
      return true;
    }

    return false;
  };

  const claimLeadership = () => {
    localStorage.setItem(STORAGE_KEYS.leaderTabId, TAB_ID);
    localStorage.setItem(STORAGE_KEYS.leaderHeartbeat, Date.now().toString());
  };

  const updateLeaderHeartbeat = () => {
    if (localStorage.getItem(STORAGE_KEYS.leaderTabId) === TAB_ID) {
      localStorage.setItem(STORAGE_KEYS.leaderHeartbeat, Date.now().toString());
    }
  };

  const clearLeadership = () => {
    if (localStorage.getItem(STORAGE_KEYS.leaderTabId) === TAB_ID) {
      localStorage.removeItem(STORAGE_KEYS.leaderTabId);
      localStorage.removeItem(STORAGE_KEYS.leaderHeartbeat);
    }
    state.isLeader = false;
  };

  // Audio System (from Chain Warn v2)
  const audioContext = new AudioContext();

  const playTone = (gain, frequency, duration) => {
    const osc = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    osc.connect(gainNode);
    osc.frequency.value = frequency;
    osc.type = "square";
    gainNode.connect(audioContext.destination);
    gainNode.gain.value = gain * 0.01;
    osc.start(audioContext.currentTime);
    osc.stop(audioContext.currentTime + duration * 0.001);
  };

  const playAlert = () => {
    playTone(10, 233, 100);
    playTone(3, 603, 200);
  };

  GM_addStyle(`
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

    .cw-button {
      margin-left: 10px;
      padding: 6px 14px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ccff;
      border: 1px solid #00ccff;
      border-radius: 6px;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 0 4px #00ccff55;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .cw-button:hover {
      background: #00ccff;
      color: #111;
      box-shadow: 0 0 10px #00ccffaa;
    }

    .cw-popup {
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: #111;
      border: 1px solid #444;
      padding: 20px;
      color: #eee;
      z-index: 10000;
      width: 320px;
      border-radius: 10px;
      font-family: Arial, sans-serif;
      box-shadow: 0 0 20px #000;
    }

    .cw-popup input[type="text"] {
      background: #222;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      font-size: 14px;
      padding: 6px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 10px;
    }

    .cw-api-key-error {
      color: #ff0000;
      font-size: 12px;
      margin-top: -8px;
      margin-bottom: 10px;
      display: none;
      font-weight: bold;
    }

    .cw-popup .threshold-group {
      margin-bottom: 14px;
    }

    .cw-popup .threshold-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 13px;
    }

    .cw-popup .threshold-group .mins-secs {
      display: flex;
      gap: 8px;
    }

    .cw-popup .threshold-group .mins-secs input {
      width: 100px;
    }

    .cw-popup button.save-changes {
      width: 100%;
      padding: 8px;
      margin-top: 10px;
      background: #28a745;
      border: none;
      color: #fff;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .cw-popup button.save-changes:hover {
      background: #218838;
    }

    .cw-close {
      position: absolute;
      top: 6px;
      right: 10px;
      color: #ccc;
      font-size: 16px;
      cursor: pointer;
    }

    .cw-close:hover {
      color: #f66;
    }

    .cw-toggle {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      border: none;
      border-radius: 999px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s ease;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
    }

    .cw-toggle.on {
      background: #28a745;
    }

    .cw-toggle.off {
      background: #dc3545;
    }

    .cw-title-timer {
      font-size: 22px;
      font-weight: bold;
      margin-left: 10px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      color: #00ccff;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .cw-api-warning {
      display: block;
      font-size: 11px;
      font-weight: bold;
      margin-left: 10px;
      margin-top: 5px;
      font-family: 'Orbitron', sans-serif;
      color: #ff0000;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .cw-flash {
      animation: flash 1s infinite;
    }

    @keyframes flash {
      0% { opacity: 1; }
      50% { opacity: 0.4; }
      100% { opacity: 1; }
    }

    .cw-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255,0,0,0.5);
      z-index: 10001;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .cw-overlay-timer {
      font-size: 100px;
      font-weight: bold;
      color: red;
      font-family: 'Orbitron', sans-serif;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .cw-overlay button {
      margin-top: 20px;
      font-size: 24px;
      padding: 10px 20px;
      background: black;
      color: white;
      border: 2px solid red;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
    }
  `);

  const secToMMSS = sec => `${Math.floor(sec / 60)}:${(sec % 60).toString().padStart(2, '0')}`;

  const getDOMTimer = () => {
    const el = document.querySelector('.bar-timeleft___B9RGV');
    if (!el) return null;
    const [m, s] = el.innerText.split(':').map(Number);
    return isNaN(m) || isNaN(s) ? null : m * 60 + s;
  };

  const getAPITimer = () => {
    return new Promise((resolve, reject) => {
      if (!state.apiKey) return reject('no_key');
      const url = `https://api.torn.com/v2/faction/chain?key=${state.apiKey}`;
      let timeout = setTimeout(() => reject('timeout'), API_TIMEOUT);
      GM_xmlhttpRequest({
        method: "GET",
        url,
        onload: res => {
          clearTimeout(timeout);
          try {
            const json = JSON.parse(res.responseText);

            // Check for API errors
            if (json.error) {
              console.error('[Chain Watch] API Error:', json.error);
              reject('api_error');
              return;
            }

            // Check if chain.timeout field exists
            if (json.chain && json.chain.timeout !== undefined) {
              resolve(json.chain.timeout);
            } else {
              console.warn('[Chain Watch] No chain timeout in response. Faction may not be in an active chain.');
              reject('no_timeout');
            }
          } catch (err) {
            console.error('[Chain Watch] Parse error:', err);
            reject('parse_error');
          }
        },
        onerror: (err) => {
          console.error('[Chain Watch] Request error:', err);
          reject('request_error');
        }
      });
    });
  };

  const openTargetPage = (id) => {
    const url = `https://www.torn.com/loader.php?sid=attack&user2ID=${id}`;
    hideOverlay();
    window.open(url, '_blank');
  };

  const findTargetFromList = () => {
    return new Promise((resolve) => {
      const url = `https://api.torn.com/v2/user/list?cat=Targets&key=${state.apiKey}`;
      GM_xmlhttpRequest({
        method: "GET",
        url,
        onload(res) {
          try {
            const data = JSON.parse(res.responseText);
            const live = data.list?.filter(u => u.status?.state === "Okay" && u.level <= MAX_LEVEL);
            const selected = live[Math.floor(Math.random() * live.length)];
            resolve(selected?.user_id || null);
          } catch { resolve(null); }
        },
        onerror: () => resolve(null)
      });
    });
  };

  const findTargetFromFactions = (index = 0) => {
    return new Promise((resolve) => {
      if (index >= TARGET_FALLBACK_FACTIONS.length) {
        const randomId = Math.floor(Math.random() * (3900000 - 3600000) + 3600000);
        return resolve(randomId);
      }
      const fid = TARGET_FALLBACK_FACTIONS[index];
      const url = `https://api.torn.com/faction/${fid}?selections=basic&key=${state.apiKey}`;
      GM_xmlhttpRequest({
        method: "GET",
        url,
        onload(res) {
          try {
            const data = JSON.parse(res.responseText);
            const members = Object.values(data.members || {});
            const live = members.filter(m => m.status?.state === "Okay" && m.level <= MAX_LEVEL);
            const chosen = live[Math.floor(Math.random() * live.length)];
            if (chosen) resolve(chosen.user_id);
            else findTargetFromFactions(index + 1).then(resolve);
          } catch {
            findTargetFromFactions(index + 1).then(resolve);
          }
        },
        onerror: () => findTargetFromFactions(index + 1).then(resolve)
      });
    });
  };

  const findTarget = async () => {
    const idFromList = await findTargetFromList();
    if (idFromList) return openTargetPage(idFromList);
    const idFromFacs = await findTargetFromFactions();
    if (idFromFacs) return openTargetPage(idFromFacs);
  };

  const showOverlay = (seconds) => {
    // Only show overlay on leader tab
    if (!state.isLeader) return;
    if (state.overlay) return;

    const overlay = document.createElement('div');
    overlay.className = 'cw-overlay';
    overlay.innerHTML = `
      <div class="cw-overlay-timer">${secToMMSS(seconds)}</div>
      <button id="cw-save-chain-btn">Save the Chain!</button>
      <div style="margin-top:8px; color:#fff; font-size:16px;">(press ESC to dismiss)</div>
    `;
    overlay.querySelector('#cw-save-chain-btn').onclick = () => {
      hideOverlay();
      findTarget();
    };
    document.body.appendChild(overlay);
    state.overlay = overlay;

    const escHandler = e => {
      if (e.key === 'Escape') {
        hideOverlay();
      }
    };
    document.addEventListener('keydown', escHandler);

    overlay._escHandler = escHandler;

    // Start audio alarm (leader tab only)
    if (!state.audioAlarm) {
      state.audioAlarm = setInterval(playAlert, 1500);
    }
  };

  const hideOverlay = () => {
    if (state.overlay) {
      document.removeEventListener('keydown', state.overlay._escHandler);
      state.overlay.remove();
      state.overlay = null;
    }

    // Stop audio alarm
    if (state.audioAlarm) {
      clearInterval(state.audioAlarm);
      state.audioAlarm = null;
    }

    state.overlayDismissed = true;
  };

  const updateOverlay = (seconds) => {
    if (state.overlay) {
      const timerEl = state.overlay.querySelector('.cw-overlay-timer');
      if (timerEl) {
        timerEl.textContent = secToMMSS(seconds);
      }
    }
  };

  const validateAPIKey = (apiKey) => {
    return new Promise((resolve, reject) => {
      if (!apiKey || apiKey.trim() === '') return reject('empty');
      const url = `https://api.torn.com/v2/faction/chain?key=${apiKey}`;
      const timeout = setTimeout(() => reject('timeout'), API_TIMEOUT);
      GM_xmlhttpRequest({
        method: "GET",
        url,
        onload: res => {
          clearTimeout(timeout);
          try {
            const json = JSON.parse(res.responseText);
            if (json.error) {
              reject('invalid');
            } else {
              resolve(true);
            }
          } catch { reject('invalid'); }
        },
        onerror: () => reject('error')
      });
    });
  };

  const showSettingsPanel = () => {
    const wrap = document.createElement('div');
    wrap.className = 'cw-popup';

    const upM = state.thresholds.upper != null ? Math.floor(state.thresholds.upper / 60) : '';
    const upS = state.thresholds.upper != null ? (state.thresholds.upper % 60) : '';
    const midM = state.thresholds.middle != null ? Math.floor(state.thresholds.middle / 60) : '';
    const midS = state.thresholds.middle != null ? (state.thresholds.middle % 60) : '';
    const lowM = state.thresholds.lower != null ? Math.floor(state.thresholds.lower / 60) : '';
    const lowS = state.thresholds.lower != null ? (state.thresholds.lower % 60) : '';

    wrap.innerHTML = `
      <button id="cw-toggle" class="cw-toggle ${state.enabled ? 'on' : 'off'}">
        ${state.enabled ? 'Chain Watch ON' : 'Chain Watch OFF'}
      </button>
      <input id="cw-apikey" type="text" placeholder="API Key (limited)" value="${state.apiKey}" />
      <div id="cw-api-key-error" class="cw-api-key-error">API Key Invalid</div>

      <div class="threshold-group">
        <label>Upper Threshold</label>
        <div class="mins-secs">
          <input id="cw-upper-mins" type="text" placeholder="Minutes" value="${upM}" />
          <input id="cw-upper-secs" type="text" placeholder="Seconds" value="${upS}" />
        </div>
      </div>

      <div class="threshold-group">
        <label>Middle Threshold</label>
        <div class="mins-secs">
          <input id="cw-middle-mins" type="text" placeholder="Minutes" value="${midM}" />
          <input id="cw-middle-secs" type="text" placeholder="Seconds" value="${midS}" />
        </div>
      </div>

      <div class="threshold-group">
        <label>Lower Threshold</label>
        <div class="mins-secs">
          <input id="cw-lower-mins" type="text" placeholder="Minutes" value="${lowM}" />
          <input id="cw-lower-secs" type="text" placeholder="Seconds" value="${lowS}" />
        </div>
      </div>

      <button id="cw-save" class="save-changes">Save Changes</button>
      <div class="cw-close">âœ–</div>
    `;
    wrap.querySelector('#cw-toggle').onclick = e => {
      state.enabled = !state.enabled;
      localStorage.setItem(STORAGE_KEYS.enabled, state.enabled);
      e.target.className = 'cw-toggle ' + (state.enabled ? 'on' : 'off');
      e.target.textContent = state.enabled ? 'Chain Watch ON' : 'Chain Watch OFF';

      if (!state.enabled) {
        // Disabling - clean up everything
        const existing = document.getElementById('cw-duplicate-timer');
        if (existing) existing.remove();
        if (state.interval) {
          clearInterval(state.interval);
          state.interval = null;
        }
        hideOverlay();
        hideAPIWarning();
        clearLeadership();
      }
      // Note: interval is already running from init, no need to start here
    };
    wrap.querySelector('#cw-save').onclick = async () => {
      const api = wrap.querySelector('#cw-apikey').value.trim();
      const errorEl = wrap.querySelector('#cw-api-key-error');

      // Validate API key if one was provided
      if (api) {
        try {
          await validateAPIKey(api);
          errorEl.style.display = 'none';
        } catch (error) {
          errorEl.style.display = 'block';
          return; // Don't save if invalid
        }
      } else {
        errorEl.style.display = 'none';
      }

      const upMins = parseInt(wrap.querySelector('#cw-upper-mins').value, 10);
      const upSecs = parseInt(wrap.querySelector('#cw-upper-secs').value, 10);
      const midMins = parseInt(wrap.querySelector('#cw-middle-mins').value, 10);
      const midSecs = parseInt(wrap.querySelector('#cw-middle-secs').value, 10);
      const lowMins = parseInt(wrap.querySelector('#cw-lower-mins').value, 10);
      const lowSecs = parseInt(wrap.querySelector('#cw-lower-secs').value, 10);

      state.apiKey = api;
      localStorage.setItem(STORAGE_KEYS.apiKey, api);

      const thresholds = {};
      if (!isNaN(upMins) && !isNaN(upSecs)) thresholds.upper = upMins * 60 + upSecs;
      if (!isNaN(midMins) && !isNaN(midSecs)) thresholds.middle = midMins * 60 + midSecs;
      if (!isNaN(lowMins) && !isNaN(lowSecs)) thresholds.lower = lowMins * 60 + lowSecs;

      state.thresholds = thresholds;
      localStorage.setItem(STORAGE_KEYS.thresholds, JSON.stringify(thresholds));

      // Automatically enable
      state.enabled = true;
      localStorage.setItem(STORAGE_KEYS.enabled, 'true');

      wrap.remove();
      // Note: interval is already running from init, will start working on next tick
    };
    wrap.querySelector('.cw-close').onclick = () => wrap.remove();
    document.body.appendChild(wrap);
  };

  const injectTimerUI = () => {
    const h4 = document.querySelector('h4');
    if (!h4 || document.getElementById('cw-duplicate-timer')) return;

    const timerEl = document.createElement('span');
    timerEl.className = 'cw-title-timer';
    timerEl.id = 'cw-duplicate-timer';
    timerEl.title = 'Click to Save Chain!';
    timerEl.onclick = findTarget;
    h4.appendChild(timerEl);
  };

  const injectUIIfFactionPage = () => {
    if (!location.href.includes('/factions.php')) return;
    const h4 = document.querySelector('h4');
    if (!h4 || document.querySelector('.cw-button')) return;
    const btn = document.createElement('button');
    btn.className = 'cw-button';
    btn.textContent = 'ðŸ”— Chain Watch ðŸ”—';
    btn.onclick = showSettingsPanel;
    h4.parentElement.appendChild(btn);
  };

  const showAPIWarning = (message) => {
    const timerEl = document.getElementById('cw-duplicate-timer');
    if (!timerEl) return;

    // Update existing warning if present, or create new one
    let warningEl = document.getElementById('cw-api-warning');
    if (warningEl) {
      warningEl.textContent = message;
    } else {
      warningEl = document.createElement('span');
      warningEl.className = 'cw-api-warning';
      warningEl.id = 'cw-api-warning';
      warningEl.textContent = message;
      // Insert warning after timer in the same h4
      timerEl.parentElement.appendChild(warningEl);
    }
  };

  const hideAPIWarning = () => {
    const warningEl = document.getElementById('cw-api-warning');
    if (warningEl) {
      warningEl.remove();
    }
  };

  const showDesktopNotification = () => {
    if (!('Notification' in window)) return;

    // Check if a notification was recently shown by another tab
    const lastNotification = parseInt(localStorage.getItem(STORAGE_KEYS.lastNotification) || '0', 10);
    const now = Date.now();
    const timeSinceLastNotification = now - lastNotification;

    // If a notification was shown in the last 5 seconds, skip (another tab already notified)
    if (timeSinceLastNotification < 5000) return;

    // Mark that we're showing a notification now
    localStorage.setItem(STORAGE_KEYS.lastNotification, now.toString());

    if (Notification.permission === 'granted') {
      new Notification('Chain Watch - API Failure', {
        body: 'API connection failed. Keep Torn window active for timer accuracy.',
        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="75" font-size="75">ðŸ”—</text></svg>',
        requireInteraction: false
      });
    } else if (Notification.permission !== 'denied') {
      Notification.requestPermission().then(permission => {
        if (permission === 'granted') {
          showDesktopNotification();
        }
      });
    }
  };

  const runLoop = () => {
    if (!state.enabled) return;

    const now = Date.now();

    // Cache DOM element references (query once per loop)
    const timerEl = document.getElementById('cw-duplicate-timer');
    const domTimerEl = document.querySelector('.bar-timeleft___B9RGV');

    // Check leadership status (with caching to reduce localStorage reads)
    const previousLeaderStatus = state.isLeader;
    const isLeaderTab = isLeader();
    state.isLeader = isLeaderTab;

    // Update heartbeat only every 2 seconds (not every loop)
    if (isLeaderTab && (now - state.lastHeartbeatUpdate) >= HEARTBEAT_UPDATE_INTERVAL) {
      updateLeaderHeartbeat();
      state.lastHeartbeatUpdate = now;
    }

    // Only update timer visibility when leadership status changes
    if (isLeaderTab !== previousLeaderStatus) {
      if (timerEl) {
        timerEl.style.display = isLeaderTab ? '' : 'none';
      }
    }

    // Only leader tab processes timer logic and makes API calls
    if (!isLeaderTab) return;

    // Ensure timer UI is injected (only if it doesn't exist)
    if (!timerEl) {
      injectTimerUI();
      return; // Wait for next loop to process
    }

    const hasAPIKey = state.apiKey && state.apiKey.trim() !== '';

    // Check if we're in cooldown period (after 3 failures)
    const inCooldown = now < state.apiCooldownUntil;

    // Determine if it's time to attempt an API call
    const timeSinceLastAttempt = now - state.lastAPIAttemptTime;
    const shouldAttemptAPI = hasAPIKey && !inCooldown && timeSinceLastAttempt >= API_PING_INTERVAL;

    // Fire API call in background (non-blocking)
    if (shouldAttemptAPI) {
      // Mark that we attempted the API call (prevent duplicate calls)
      state.lastAPIAttemptTime = now;

      // Fire API call asynchronously without blocking
      getAPITimer()
        .then(fetchedValue => {
          // Success! Update stored values, reset failure counter, clear cooldown
          state.lastFetchedValue = fetchedValue;
          state.lastFetchedTime = Date.now();
          state.consecutiveAPIFailures = 0;
          state.apiCooldownUntil = 0;
          state.usingDOMFallback = false;
        })
        .catch(error => {
          // API failed, increment failure counter
          state.consecutiveAPIFailures++;

          // If we've hit max failures, switch to DOM and set 1-minute cooldown
          if (state.consecutiveAPIFailures >= MAX_API_FAILURES) {
            state.usingDOMFallback = true;
            state.apiCooldownUntil = Date.now() + 60000; // 1 minute from now
            console.log('[Chain Watch] API failed 3 consecutive times. Switching to DOM fallback for 1 minute.');

            // Fetch from DOM now that we've switched
            const domValue = getDOMTimer();
            if (domValue != null) {
              state.lastFetchedValue = domValue;
              state.lastFetchedTime = Date.now();
            }
          }
          // If less than 3 failures, keep using timestamp-based calculation from last successful API fetch
        });
    }

    // Update from DOM if in fallback mode or no API key
    if (inCooldown || (hasAPIKey && state.usingDOMFallback)) {
      // We're in DOM fallback mode (either during cooldown or until API succeeds)
      // Update from DOM every loop
      const domValue = getDOMTimer();
      if (domValue != null) {
        state.lastFetchedValue = domValue;
        state.lastFetchedTime = Date.now();
      }
    } else if (!hasAPIKey) {
      // No API key - always use DOM
      const domValue = getDOMTimer();
      if (domValue != null) {
        state.lastFetchedValue = domValue;
        state.lastFetchedTime = Date.now();
      }
      state.usingDOMFallback = true; // Mark as using DOM
    }

    // Detect API state changes and show/hide warning
    if (!hasAPIKey) {
      // No API key provided - show no API key warning
      showAPIWarning('Warning: API Key not found. Side bar monitoring enabled. Maintain an active Torn Window to ensure Chain Watch functionality.');
    } else if (state.usingDOMFallback) {
      // Has API key but it's failing - show API failure warning
      if (!state.previouslyUsingDOMFallback) {
        // Just transitioned to failure - show notification
        if (!state.apiFailureNotified) {
          showDesktopNotification();
          state.apiFailureNotified = true;
        }
      }
      showAPIWarning('Warning: API Failed. Maintain an active Torn window to ensure Chain Watch functionality!');
    } else {
      // API is working (or we have valid key and it's working) - hide warning
      hideAPIWarning();
      state.apiFailureNotified = false;
    }

    // Update previous state for next iteration
    state.previouslyUsingDOMFallback = state.usingDOMFallback;

    // Calculate current timer value
    let sec = null;
    if (state.lastFetchedValue != null && state.lastFetchedTime != null) {
      if (state.usingDOMFallback) {
        // DOM mode: use the value directly (updated every loop from DOM)
        sec = state.lastFetchedValue;
      } else {
        // API mode: calculate based on elapsed time for smooth countdown
        const elapsedMs = Date.now() - state.lastFetchedTime;
        const elapsedSec = Math.floor(elapsedMs / 1000);
        sec = Math.max(0, state.lastFetchedValue - elapsedSec);
      }
    }

    // If we don't have any timer value yet, bail
    if (sec == null) return;

    // Update timer display
    if (timerEl) timerEl.textContent = 'ðŸ”— Chain ðŸ”— ' + secToMMSS(sec);

    // Only update document title when timer value changes
    if (sec !== state.lastDisplayedSeconds) {
      const originalTitle = document.title.replace(/^\d+:\d+\sâ€”\s*/, '');
      document.title = `${secToMMSS(sec)} â€” ${originalTitle}`;
      state.lastDisplayedSeconds = sec;
    }

    // -- Reset dismissal when timer goes above threshold
    if (state.thresholds.lower != null && sec > state.thresholds.lower) {
      state.overlayDismissed = false;
    }

    if (state.thresholds.lower != null && sec <= state.thresholds.lower && !state.overlayDismissed) {
      showOverlay(sec);
    } else {
      hideOverlay();
    }

    if (state.thresholds.middle && sec <= state.thresholds.middle) {
      timerEl?.classList.add('cw-flash');
      domTimerEl?.classList.add('cw-flash');
    } else {
      timerEl?.classList.remove('cw-flash');
      domTimerEl?.classList.remove('cw-flash');
    }

    if (state.thresholds.upper && sec <= state.thresholds.upper) {
      if (timerEl) timerEl.style.color = 'red';
      if (domTimerEl) domTimerEl.style.color = 'red';
    } else {
      if (timerEl) timerEl.style.color = '';
      if (domTimerEl) domTimerEl.style.color = '';
    }

    updateOverlay(sec);
  };

  const init = () => {
    // Claim leadership when tab becomes active
    window.addEventListener('focus', () => {
      claimLeadership();
    });

    window.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        claimLeadership();
      }
    });

    // Claim leadership on init if no one else is leader
    isLeader();

    // Inject UI elements
    injectTimerUI();
    injectUIIfFactionPage();

    // Keep trying to inject faction button until it appears (for late-loading pages)
    let factionButtonRetries = 0;
    const maxRetries = 20; // 10 seconds total
    const factionButtonInterval = setInterval(() => {
      injectUIIfFactionPage();
      factionButtonRetries++;
      if (document.querySelector('.cw-button') || factionButtonRetries >= maxRetries) {
        clearInterval(factionButtonInterval);
      }
    }, 500);

    // Start the main loop (always run, runLoop checks state.enabled internally)
    state.interval = setInterval(runLoop, 1000);
  };

  init();
})();
